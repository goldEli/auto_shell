#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { parse } = require('@babel/parser');
const traverse = require('@babel/traverse').default;
const { parseComponent, compile } = require('vue-template-compiler');


// ÈÄíÂΩíÈÅçÂéÜ Vue AST
function traverseVueAst(node, cb) {
    if (!node) return

    // Ë°®ËææÂºè (ÊèíÂÄº or ÁªëÂÆö)
    if (node.expression) {
        cb(node.expression)
    }
    if (node.attrsMap) {
        Object.values(node.attrsMap).forEach(val => cb(val))
    }

    if (node.children) {
        node.children.forEach(child => traverseVueAst(child, cb))
    }
}

// 3. Babel Ëß£ÊûêË°®ËææÂºè ASTÔºåÊèêÂèñ $t ÁöÑÂèÇÊï∞
function extractTKeys(content) {
    try {
        // const ast = babelParser.parseExpression(expr)

        const ast = parse(content, {
            sourceType: 'module',
            plugins: ['jsx', 'typescript']
        });
        const keys = []

        traverse(ast, {
            CallExpression(path) {
                if (
                    (path.node.callee.type === 'MemberExpression' &&
                        path.node.callee.property.name === '$t') ||
                    (path.node.callee.type === 'Identifier' &&
                        path.node.callee.name === '$t')
                ) {
                    const arg = path.node.arguments[0]
                    if (arg && arg.type === 'StringLiteral') {
                        keys.push(arg.value)
                    }
                }
            }
        })

        return keys
    } catch (e) {
        return []
    }
}

function scanTemplate(templateContent) {
    const res = compile(templateContent)

    const allKeys = []
    traverseVueAst(res.ast, expr => {
        // console.log(expr, filePath);
        const keys = extractTKeys(expr)
        if (keys.length) {
            allKeys.push(...keys)
            // for (const key of keys) {
            //     // console.log(key, filePath);
            //     this.addKeyUsage(key, filePath, routePrefix);
            // }
        }
    })

    return allKeys
}


function findI18nCalls(content) {

    const ast = parse(content, {
        sourceType: 'module',
        plugins: ['jsx', 'typescript']
    });

    const keys = []
    traverse(ast, {
        CallExpression(path) {
            if (
                (path.node.callee.type === 'MemberExpression' &&
                    path.node.callee.property.name === '$t') ||
                (path.node.callee.type === 'Identifier' &&
                    path.node.callee.name === '$t')
            ) {
                const arg = path.node.arguments[0]
                if (arg && arg.type === 'StringLiteral') {
                    keys.push(arg.value)
                    // self.addKeyUsage(arg.value, filePath, routePrefix);
                }
            }
        }
    })
    return keys

    // traverse(ast, {
    //     CallExpression(path) {
    //         const { callee, arguments: args } = path.node;

    //         if (callee.type === 'MemberExpression' && 
    //             callee.object.name === '$t' && 
    //             args.length > 0 && 
    //             args[0].type === 'StringLiteral') {

    //             console.log(args[0].value, filePath);

    //             const key = args[0].value;
    //             self.addKeyUsage(key, filePath, routePrefix);
    //         }
    //     }
    // });
}

// Êñá‰ª∂ÊòØÂê¶Â≠òÂú®
/**
 * Âà§Êñ≠Ë∑ØÂæÑÊòØÂê¶ÊòØÊñá‰ª∂
 * @param {string} filePath - Êñá‰ª∂Ë∑ØÂæÑ
 * @returns {boolean}
 */
function isFile(filePath) {
    try {
        const stat = fs.statSync(filePath);
        return stat.isFile();
    } catch (err) {
        // Ë∑ØÂæÑ‰∏çÂ≠òÂú®ÊàñÂÖ∂‰ªñÈîôËØØ
        return false;
    }
}

class I18nKeyFinder {
    constructor(i18nFilePath, outputFilePath) {
        this.i18nFilePath = i18nFilePath;
        this.outputFilePath = outputFilePath;
        this.i18nKeys = new Set();
        this.keyUsageMap = new Map(); // key -> { pages: Set, routes: Set }
        this.projectRoot = this.findProjectRoot();
        this.scannedFiles = new Set(); // Èò≤Ê≠¢ÈáçÂ§çÊâ´Êèè
    }

    findProjectRoot() {
        let currentDir = process.cwd();
        while (currentDir !== path.dirname(currentDir)) {
            if (fs.existsSync(path.join(currentDir, 'nuxt.config.js')) ||
                fs.existsSync(path.join(currentDir, 'nuxt.config.ts')) ||
                fs.existsSync(path.join(currentDir, 'package.json'))) {
                return currentDir;
            }
            currentDir = path.dirname(currentDir);
        }
        return process.cwd();
    }

    loadI18nFile() {
        try {
            const content = fs.readFileSync(this.i18nFilePath, 'utf-8');
            const data = JSON.parse(content);
            this.extractKeys(data);
            console.log(`‚úÖ ÊàêÂäüÂä†ËΩΩ i18n Êñá‰ª∂: ${this.i18nFilePath}`);
            console.log(`üìä ÂèëÁé∞ ${this.i18nKeys.size} ‰∏™ i18n key`);
        } catch (error) {
            console.error(`‚ùå Âä†ËΩΩ i18n Êñá‰ª∂Â§±Ë¥•: ${error.message}`);
            process.exit(1);
        }
    }

    extractKeys(obj, prefix = '') {
        for (const [key, value] of Object.entries(obj)) {
            const currentKey = prefix ? `${prefix}.${key}` : key;
            this.i18nKeys.add(currentKey);

            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                this.extractKeys(value, currentKey);
            }
        }
    }

    // Ëß£Êûê script ‰∏≠ÁöÑ import ËØ≠Âè•
    extractImports(scriptContent) {
        try {
            const ast = parse(scriptContent, {
                sourceType: 'module',
                plugins: ['jsx', 'typescript']
            });

            const imports = [];
            traverse(ast, {
                ImportDeclaration(path) {
                    const source = path.node.source.value;
                    imports.push(source);
                }
            });

            return imports;
        } catch (error) {
            console.error(`‚ö†Ô∏è Ëß£Êûê import ËØ≠Âè•Â§±Ë¥•: ${error.message}`);
            return [];
        }
    }

    // Ëß£Êûê import Ë∑ØÂæÑ‰∏∫ÂÆûÈôÖÊñá‰ª∂Ë∑ØÂæÑ
    resolveImportPath(importPath, currentFilePath) {
        const currentDir = path.dirname(currentFilePath);
        const extensions = ['.js', '.vue', '/index.vue', '/index.js'];

        // Â§ÑÁêÜÁõ∏ÂØπË∑ØÂæÑ
        if (importPath.startsWith('./') || importPath.startsWith('../')) {
            const resolvedPath = path.resolve(currentDir, importPath);

            // Â∞ùËØï‰∏çÂêåÁöÑÊñá‰ª∂Êâ©Â±ïÂêç
            for (const ext of extensions) {
                const fullPath = resolvedPath + ext;
                if (isFile(fullPath)) {
                    return fullPath;
                }
            }

            // Â∞ùËØï index Êñá‰ª∂
            for (const ext of extensions) {
                const indexPath = path.join(resolvedPath, 'index' + ext);
                if (isFile(indexPath)) {
                    return indexPath;
                }
            }
        }

        // Â§ÑÁêÜÁªùÂØπË∑ØÂæÑÊàñ node_modules
        if (importPath.startsWith('/') || importPath.startsWith('@/')) {
            let resolvedPath;
            if (importPath.startsWith('@/')) {
                // Â§ÑÁêÜ @ Âà´ÂêçÔºåÈÄöÂ∏∏ÊåáÂêë src ÁõÆÂΩï
                resolvedPath = path.join(this.projectRoot, 'src', importPath.slice(2));
            } else {
                resolvedPath = path.resolve(this.projectRoot, importPath);
            }

            for (const ext of extensions) {
                const fullPath = resolvedPath + ext;
                if (isFile(fullPath)) {
                    return fullPath;
                }
            }
        }


        if (['~/', '@/'].some(prefix => importPath.startsWith(prefix))) {
            let resolvedPath;
            resolvedPath = path.join(this.projectRoot, 'client', importPath.slice(2));

            if (isFile(resolvedPath)) {
                return resolvedPath;
            }

            for (const ext of extensions) {
                const fullPath = resolvedPath + ext;
                if (isFile(fullPath)) {
                    return fullPath;
                }
            }
        }


        // @
        if (importPath.startsWith('@')) {
            let resolvedPath;
            resolvedPath = path.join(this.projectRoot, 'client', importPath.slice(1));

            if (isFile(resolvedPath)) {
                return resolvedPath;
            }

            for (const ext of extensions) {
                const fullPath = resolvedPath + ext;
                if (isFile(fullPath)) {
                    return fullPath;
                }
            }
        }





        return null;
    }

    // ÈÄíÂΩíÊâ´Êèè import Êñá‰ª∂
    scanImportedFiles(imports, currentFilePath, routePrefix) {
        // console.log(imports, currentFilePath, routePrefix);
        for (const importPath of imports) {
            const resolvedPath = this.resolveImportPath(importPath, currentFilePath);
            // console.log(resolvedPath, importPath, currentFilePath );
            if (importPath == "@components/spot/TradeDetail") {
                console.log("11111111111111111111")
                console.log(resolvedPath, routePrefix, resolvedPath)
            }

            if (resolvedPath && !this.scannedFiles.has(resolvedPath)) {
                this.scannedFiles.add(resolvedPath);
                // console.log(`üîç Êâ´Êèè import Êñá‰ª∂: ${path.relative(this.projectRoot, resolvedPath)}`);

                try {
                    const content = fs.readFileSync(resolvedPath, 'utf-8');
                    const ext = path.extname(resolvedPath);

                    if (ext === '.vue') {
                        this.scanVueFile(content, resolvedPath, routePrefix);
                    } else if (ext === '.js' || ext === '.ts') {
                        this.scanJsFile(content, resolvedPath, routePrefix);
                    }
                } catch (error) {
                    console.error(`‚ö†Ô∏è Êâ´Êèè import Êñá‰ª∂Â§±Ë¥• ${resolvedPath}: ${error.message}`);
                }
            }
        }
    }

    scanPagesDirectory() {
        const pagesDir = path.join(this.projectRoot, 'client/pages');
        if (!fs.existsSync(pagesDir)) {
            console.log(`‚ö†Ô∏è  pages ÁõÆÂΩï‰∏çÂ≠òÂú®: ${pagesDir}`);
            return;
        }

        console.log(`üîç ÂºÄÂßãÊâ´ÊèèÈ°µÈù¢ÁõÆÂΩï: ${pagesDir}`);
        this.scanDirectory(pagesDir, '');
    }

    scanDirectory(dir, routePrefix) {
        const items = fs.readdirSync(dir);

        for (const item of items) {
            const fullPath = path.join(dir, item);
            const stat = fs.statSync(fullPath);

            if (stat.isDirectory()) {
                // ÈÄíÂΩíÊâ´ÊèèÂ≠êÁõÆÂΩï
                const newPrefix = routePrefix ? `${routePrefix}/${item}` : item;
                this.scanDirectory(fullPath, newPrefix);
            } else if (this.isPageFile(item)) {
                // Êâ´ÊèèÈ°µÈù¢Êñá‰ª∂
                this.scanPageFile(fullPath, routePrefix);
            }
        }
    }

    isPageFile(filename) {
        return filename.endsWith('.vue') || filename.endsWith('.js') || filename.endsWith('.ts');
    }

    scanPageFile(filePath, routePrefix) {
        try {
            const content = fs.readFileSync(filePath, 'utf-8');
            const filename = path.basename(filePath);

            if (filename.endsWith('.vue')) {
                this.scanVueFile(content, filePath, routePrefix);
            } else {
                this.scanJsFile(content, filePath, routePrefix);
            }
        } catch (error) {
            console.error(`‚ö†Ô∏è Êâ´ÊèèÊñá‰ª∂Â§±Ë¥• ${filePath}: ${error.message}`);
        }
    }

    scanVueFile(content, filePath, routePrefix) {
        try {
            const result = parseComponent(content);

            // Êâ´Êèè template
            if (result.template) {
                const keys = scanTemplate(result.template.content);
                if (filePath === '/Users/eli/Documents/weex/projects/web-trade/client/components/spot/TradeDetail.vue') {
                    console.log(222222222222)
                    console.log(keys, routePrefix)
                }
                for (const key of keys) {
                    this.addKeyUsage(key, filePath, routePrefix);
                }
            }

            // Êâ´Êèè script
            if (result.script) {
                this.scanScript(result.script.content, filePath, routePrefix);

                // ÈÄíÂΩíÊâ´Êèè script ‰∏≠ÁöÑ import Êñá‰ª∂
                const imports = this.extractImports(result.script.content);
                if (imports.length > 0) {
                    // console.log(`üì¶ ÂèëÁé∞ ${imports.length} ‰∏™ import ËØ≠Âè•ÔºåÂºÄÂßãÈÄíÂΩíÊâ´Êèè...`);
                    this.scanImportedFiles(imports, filePath, routePrefix);
                }
            }

            // Â¶ÇÊûúËß£ÊûêÊàêÂäü‰ΩÜÊ≤°ÊúâÊâæÂà∞ÂÜÖÂÆπÔºå‰πü‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºè‰Ωú‰∏∫Ë°•ÂÖÖ
            if (!result.template) {
                console.log(`üìù Vue Ëß£ÊûêÊàêÂäü‰ΩÜÊú™ÊâæÂà∞Ê®°ÊùøÔºå‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèË°•ÂÖÖÊâ´Êèè`);
                this.scanVueFileWithRegex(content, filePath, routePrefix);
            }
        } catch (error) {
            console.error(`‚ö†Ô∏è Ëß£Êûê Vue Êñá‰ª∂Â§±Ë¥• ${filePath}: ${error.message}`);
            // Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊâ´ÊèèÊï¥‰∏™Êñá‰ª∂
            this.scanVueFileWithRegex(content, filePath, routePrefix);
        }
    }

    scanVueFileWithRegex(content, filePath, routePrefix) {
        console.log(`üîç ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊâ´Êèè Vue Êñá‰ª∂: ${path.basename(filePath)}`);

        // ‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºèÊü•ÊâæÊ®°Êùø‰∏≠ÁöÑ i18n Ë∞ÉÁî®
        const i18nPatterns = [
            /\{\{\s*\$t\(['"`]([^'"`]+)['"`]\)\s*\}\}/g,
            /\{\{\s*\$tc\(['"`]([^'"`]+)['"`]\)\s*\}\}/g,
            /\{\{\s*\$te\(['"`]([^'"`]+)['"`]\)\s*\}\}/g,
            /\{\{\s*\$d\(['"`]([^'"`]+)['"`]\)\s*\}\}/g
        ];

        let totalMatches = 0;
        i18nPatterns.forEach((pattern, index) => {
            let match;
            let matchCount = 0;
            while ((match = pattern.exec(content)) !== null) {
                const key = match[1];
                this.addKeyUsage(key, filePath, routePrefix);
                matchCount++;
                totalMatches++;
            }
            if (matchCount > 0) {
                console.log(`   Pattern ${index + 1} ÊâæÂà∞ ${matchCount} ‰∏™ÂåπÈÖç`);
            }
        });

        console.log(`   üìä Ê®°Êùø‰∏≠ÊÄªÂÖ±ÊâæÂà∞ ${totalMatches} ‰∏™ i18n Ë∞ÉÁî®`);

        // Êâ´Êèè script ÈÉ®ÂàÜ
        const scriptMatch = content.match(/<script[^>]*>([\s\S]*?)<\/script>/);
        if (scriptMatch) {
            const scriptContent = scriptMatch[1];
            console.log(`   üìú ÊâæÂà∞ script Ê†áÁ≠æÔºåÂºÄÂßãÊâ´Êèè...`);
            this.scanScriptWithRegex(scriptContent, filePath, routePrefix);
        } else {
            console.log(`   üìú Êú™ÊâæÂà∞ script Ê†áÁ≠æ`);
        }
    }

    scanJsFile(content, filePath, routePrefix) {
        try {
            const keys = findI18nCalls(content);
            for (const key of keys) {
                this.addKeyUsage(key, filePath, routePrefix);
            }

            // ÈÄíÂΩíÊâ´Êèè JS/TS Êñá‰ª∂‰∏≠ÁöÑ import Êñá‰ª∂
            const imports = this.extractImports(content);
            if (imports.length > 0) {
                // console.log(`üì¶ ÂèëÁé∞ ${imports.length} ‰∏™ import ËØ≠Âè•ÔºåÂºÄÂßãÈÄíÂΩíÊâ´Êèè...`);
                this.scanImportedFiles(imports, filePath, routePrefix);
            }
        } catch (error) {
            console.error(`‚ö†Ô∏è Ëß£Êûê JS/TS Êñá‰ª∂Â§±Ë¥• ${filePath}: ${error.message}`);
        }
    }




    scanScript(scriptContent, filePath, routePrefix) {
        try {

            const keys = findI18nCalls(scriptContent);
            for (const key of keys) {
                this.addKeyUsage(key, filePath, routePrefix);
            }
        } catch (error) {
            // Â¶ÇÊûúËß£ÊûêÂ§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî®Ê≠£ÂàôË°®ËææÂºè
            this.scanScriptWithRegex(scriptContent, filePath, routePrefix);
        }
    }

    scanScriptWithRegex(scriptContent, filePath, routePrefix) {
        const i18nPatterns = [
            /\$t\(['"`]([^'"`]+)['"`]\)/g,
            /\$tc\(['"`]([^'"`]+)['"`]\)/g,
            /\$te\(['"`]([^'"`]+)['"`]\)/g,
            /\$d\(['"`]([^'"`]+)['"`]\)/g
        ];

        i18nPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(scriptContent)) !== null) {
                const key = match[1];
                this.addKeyUsage(key, filePath, routePrefix);
            }
        });
    }


    addKeyUsage(key, filePath, routePrefix) {
        if (!this.i18nKeys.has(key)) {
            return; // Âè™ÂÖ≥Ê≥® i18n Êñá‰ª∂‰∏≠Â≠òÂú®ÁöÑ key
        }

        if (!this.keyUsageMap.has(key)) {
            this.keyUsageMap.set(key, { pages: new Set(), routes: new Set() });
        }

        const usage = this.keyUsageMap.get(key);
        usage.pages.add(filePath);

        const isRoute = filePath.includes(':lang') || filePath.includes('_lang')

        // ÁîüÊàêË∑ØÁî±Ë∑ØÂæÑ
        const route = this.generateRoute(isRoute ? filePath : routePrefix);
        // console.log(routePrefix)
        // console.log(filePath)
        if (key === "trade.detail.high") {
            console.log(3333333333333333)
            console.log(routePrefix)
            console.log(filePath)
            console.log(route)
        }
        if (route) {
            usage.routes.add(route?.slice());
        }
    }

    generateRoute(filePath, routePrefix) {
        const relativePath = path.relative(path.join(this.projectRoot, 'pages'), filePath);
        const route = relativePath
            .replace(/\.(vue|js|ts)$/, '')
            .replace(/\/index$/, '')
            .replace(/\/_/, '/:') // Âä®ÊÄÅË∑ØÁî±ÂèÇÊï∞
            .replace(/\\/g, '/'); // Windows Ë∑ØÂæÑÂàÜÈöîÁ¨¶ËΩ¨Êç¢

        return route.startsWith('/') ? route : `/${route}`;
    }

    generateReport() {
        console.log('\n' + '='.repeat(80));
        console.log('üìã i18n Key ‰∏éÈ°µÈù¢Ë∑ØÁî±ÂÖ≥Á≥ªÊä•Âëä');
        console.log('='.repeat(80));

        const sortedKeys = Array.from(this.keyUsageMap.keys()).sort();

        if (sortedKeys.length === 0) {
            console.log('‚ùå Êú™ÊâæÂà∞‰ªª‰Ωï i18n key ÁöÑ‰ΩøÁî®ÊÉÖÂÜµ');
            return;
        }

        console.log(`\nüìä ÁªüËÆ°‰ø°ÊÅØ:`);
        console.log(`   - ÊÄª key Êï∞Èáè: ${this.i18nKeys.size}`);
        console.log(`   - Ë¢´‰ΩøÁî®ÁöÑ key Êï∞Èáè: ${sortedKeys.length}`);
        console.log(`   - Êú™‰ΩøÁî®ÁöÑ key Êï∞Èáè: ${this.i18nKeys.size - sortedKeys.length}`);

        console.log('\nüîç ËØ¶ÁªÜ‰ΩøÁî®ÊÉÖÂÜµ:');
        console.log('-'.repeat(80));

        // sortedKeys.forEach(key => {
        // const usage = this.keyUsageMap.get(key);
        // const routes = Array.from(usage.routes).sort();
        // const pages = Array.from(usage.pages).map(p => path.relative(this.projectRoot, p));

        // console.log(`\nüîë Key: ${key}`);
        // console.log(`   üìç Ë∑ØÁî±: ${routes.join(', ') || 'Êó†'}`);
        // console.log(`   üìÑ Êñá‰ª∂: ${pages.join(', ')}`);
        // });

        // ÊòæÁ§∫Êú™‰ΩøÁî®ÁöÑ key
        // const unusedKeys = Array.from(this.i18nKeys).filter(key => !this.keyUsageMap.has(key));
        // if (unusedKeys.length > 0) {
        //     console.log('\n‚ö†Ô∏è Êú™‰ΩøÁî®ÁöÑ i18n keys:');
        //     console.log('-'.repeat(80));
        //     unusedKeys.forEach(key => {
        //         console.log(`   ${key}`);
        //     });
        // }

        // Â¶ÇÊûúÊåáÂÆö‰∫ÜËæìÂá∫Êñá‰ª∂ÔºåÁîüÊàê JSON Êñá‰ª∂
        if (this.outputFilePath) {
            this.generateJsonOutput();
        }
    }

    generateJsonOutput() {
        try {
            const sortedKeys = Array.from(this.keyUsageMap.keys()).sort();
            const unusedKeys = Array.from(this.i18nKeys).filter(key => !this.keyUsageMap.has(key)).sort();

            const jsonResult = {
                metadata: {
                    // projectRoot: this.projectRoot,
                    i18nFile: this.i18nFilePath,
                    generatedAt: new Date().toISOString(),
                    totalKeys: this.i18nKeys.size,
                    usedKeys: sortedKeys.length,
                    unusedKeys: unusedKeys.length
                },
                statistics: {
                    totalKeys: this.i18nKeys.size,
                    usedKeys: sortedKeys.length,
                    unusedKeys: unusedKeys.length,
                    usageRate: ((sortedKeys.length / this.i18nKeys.size) * 100).toFixed(2) + '%'
                },
                keyUsage: sortedKeys.map(key => {
                    const usage = this.keyUsageMap.get(key);
                    const routes = Array.from(usage.routes).sort();
                    // const pages = Array.from(usage.pages).map(p => path.relative(this.projectRoot, p));
                    return {
                        key: key,
                        routes: routes?.map(item => {
                            let ret = item.split(':lang')?.[1] || ''
                            if (item === '_lang/spot') {
                                console.log(4444444444444444444444)
                                console.log(ret)
                            }
                            if (!ret) {
                                ret = item.split('_lang')?.[1] || ''
                            }

                            //BTC-USDT
                            if (ret.endsWith('_id')) {
                                ret = ret.slice(0, -3) + 'BTC-USDT'
                            }

                            if (ret.endsWith('_coin')) {

                                ret =  ret.slice(0, -5) + 'BTC-USDT'
                            }

                            if (ret.endsWith("_contract")) {
                                ret =  ret.slice(0, -9) + 'BTC-USDT'
                            }



                            return ret
                        }),
                        // pages: pages,
                        // routeCount: routes.length,
                        // pageCount: pages.length
                    };
                }),
                // unusedKeys: unusedKeys,
                summary: {
                    keysWithMultipleRoutes: sortedKeys.filter(key => {
                        const usage = this.keyUsageMap.get(key);
                        return usage.routes.size > 1;
                    }).length,
                    keysWithMultiplePages: sortedKeys.filter(key => {
                        const usage = this.keyUsageMap.get(key);
                        return usage.pages.size > 1;
                    }).length
                }
            };

            // ÂÜôÂÖ• JSON Êñá‰ª∂
            fs.writeFileSync(this.outputFilePath, JSON.stringify(jsonResult, null, 2), 'utf-8');
            console.log(`\nüíæ JSON ÁªìÊûúÂ∑≤‰øùÂ≠òÂà∞: ${this.outputFilePath}`);

        } catch (error) {
            console.error(`‚ùå ÁîüÊàê JSON Êñá‰ª∂Â§±Ë¥•: ${error.message}`);
        }
    }

    run() {
        console.log('üöÄ ÂºÄÂßãÂàÜÊûê Nuxt2 + Vue i18n È°πÁõÆ...');
        console.log(`üìÅ È°πÁõÆÊ†πÁõÆÂΩï: ${this.projectRoot}`);
        console.log(`üåê i18n Êñá‰ª∂: ${this.i18nFilePath}`);

        this.loadI18nFile();
        this.scanPagesDirectory();
        this.generateReport();
    }
}

// ÂëΩ‰ª§Ë°åÂèÇÊï∞Â§ÑÁêÜ
function parseArguments() {
    const args = process.argv.slice(2);
    let i18nFilePath = null;
    let outputFilePath = null;

    for (let i = 0; i < args.length; i++) {
        if (args[i] === '-f' && i + 1 < args.length) {
            i18nFilePath = args[i + 1];
        } else if (args[i] === '-o' && i + 1 < args.length) {
            outputFilePath = args[i + 1];
        }
    }

    if (!i18nFilePath) {
        console.error('‚ùå ‰ΩøÁî®ÊñπÊ≥ï: find_key_vue2 -f <i18nÊñá‰ª∂Ë∑ØÂæÑ> [-o <ËæìÂá∫Êñá‰ª∂Ë∑ØÂæÑ>]');
        console.error('   Á§∫‰æã: find_key_vue2 -f src/locales/en.json');
        console.error('   Á§∫‰æã: find_key_vue2 -f src/locales/en.json -o result.json');
        process.exit(1);
    }

    return { i18nFilePath, outputFilePath };
}

// ‰∏ªÂáΩÊï∞
function main() {
    try {
        const { i18nFilePath, outputFilePath } = parseArguments();
        const finder = new I18nKeyFinder(i18nFilePath, outputFilePath);
        finder.run();
    } catch (error) {
        console.error('‚ùå Á®ãÂ∫èÊâßË°åÂ§±Ë¥•:', error.message);
        process.exit(1);
    }
}

if (require.main === module) {
    main();
}


module.exports = I18nKeyFinder;
